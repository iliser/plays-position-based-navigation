const ce=()=>{};function $e(e,t,n){if(e==null)return t(void 0),ce;const s=e.subscribe(t,n);return s.unsubscribe?()=>s.unsubscribe():s}let T=null;function he(e){T=e}function be(e){const t=[];let n=e,s=null;for(;n!==null;){const u=n.nodeType,r=n.nextSibling;if(u===8){const o=n.data;if(o.startsWith("ssr:")){const c=o.slice(4);if(s===null)s=c;else{if(c===s)return t;t.push(n)}n=r;continue}}s!==null&&t.push(n),n=r}return null}function ft(e,t){let n=e;if(T!==null)if(t&&(n=n.firstChild),n.nodeType===8){let s=n.$$fragment;s===void 0&&(s=be(n),n.$$fragment=void 0),he(s)}else he([n.firstChild])}const ve=Object,xe=Array,ke=xe.isArray,it=xe.from,at=ve.defineProperty,ee=ve.getOwnPropertyDescriptor,k=typeof window<"u",Y=k?Node.prototype:{},Pe=k?Element.prototype:{},oe=k?EventTarget.prototype:{},Ee=Map.prototype,Ue=Y.appendChild,Ye=Y.cloneNode,Le=Ee.set,Ge=Ee.get;oe.__click=void 0;oe.__nodeValue=" ";oe.__className="";const we=k?ee(Y,"firstChild").get:null,He=k?ee(Y,"nextSibling").get:null,We=k?ee(Y,"textContent").set:null;k&&ee(Pe,"className").set;function _t(e,t){Ue.call(e,t)}function dt(e,t,n){Le.call(e,t,n)}function pt(e,t){return Ge.call(e,t)}function mt(e,t){return Ye.call(e,t)}function ht(e){const t=we.call(e);if(T!==null)if(t===null){const n=document.createTextNode("");return e.appendChild(n),n}else return le(t);return t}function gt(e){if(T!==null){const t=e[0];return T!==null&&t!==null?le(t):t}return we.call(e)}function yt(e){const t=He.call(e);return T!==null&&t!==null?le(t):t}function bt(e,t){We.call(e,t)}function le(e){if(e.nodeType===8&&e.data.startsWith("ssr:")&&T.at(-1)!==e){const t=be(e),s=(t.at(-1)||e).nextSibling;return s.$$fragment=t,s}return e}const vt=k?window:void 0,qe=1,fe=2,L=4,G=8,I=16,ie=32,H=64,te=128,h=256,m=512,F=1024,V=2048,ne=4096,ae=L|G|I|ie,Te=0,Be=1,Ke=Number.MAX_SAFE_INTEGER,P=Symbol();let X=Te,z=!1,J=!1,i=[],C=[],se=[],U=0,b=null,l=null,a=null,d=0,$=1,K=1,v=!1,ue=!1,R=null,M=!1,y=null,f=null;function Ve(e){return{effects:null,props:e,parent:f,accessors:null,context:null,immutable:!1,mounted:!1,runes:!1,update_callbacks:null}}function Q(e){const t=e||f;return t!==null&&t.runes}function Xe(e,t){return e===t}function Ne(e,t,n){return{block:n,consumers:null,context:null,dependencies:null,destroy:null,equals:null,flags:e,init:null,read:0,references:null,value:t}}function ze(e,t){const n=e.references;n===null?e.references=[t]:n.push(t)}function _e(e){const t=e.flags;if(t&m||e.value===P)return!0;if(t&F){const n=e.dependencies;if(n!==null){const s=n.length;let u;for(u=0;u<s;u++){const r=n[u];if(r.flags&F&&!_e(r)){x(r,h);continue}if(r.flags&m||r.value===P)if(r.flags&fe){if(Ae(r,!0),e.flags&m)return!0}else return!0}}}return!1}function Ce(e){const t=e.init,n=a,s=d,u=$,r=b,o=y,c=f,g=M,E=(e.flags&I)!==0,B=v;a=null,d=0,K===Ke?K=1:K++,$=K,b=e,y=e.block,f=e.context,M=l===null&&(e.flags&te)!==0,v=!1,E&&f?.update_callbacks!=null&&f.update_callbacks.execute();try{let w;E?w=t(e.block):w=t();let _=e.dependencies;if(a!==null){let p;if(Z(e,d,!1),_!==null&&d>0)for(_.length=d+a.length,p=0;p<a.length;p++)_[d+p]=a[p];else e.dependencies=_=a;if(!M)for(p=d;p<_.length;p++){const q=_[p];q.consumers===null?q.consumers=[e]:q.consumers.push(e)}}else _!==null&&d<_.length&&(Z(e,d,!1),_.length=d);return w}finally{a=n,d=s,$=u,b=r,y=o,f=c,M=g,v=B}}function Z(e,t,n){const s=e.dependencies;if(s!==null){let u;for(u=t;u<s.length;u++){const r=s[u],o=r.consumers;let c=0;if(o!==null)if(c=o.length-1,c===0)r.consumers=null;else{const g=o.indexOf(e);o[g]=o[c],o.pop()}n&&c===0&&r.flags&te&&Z(r,0,!0)}}}function Se(e){const t=e.references;if(e.references=null,t!==null){let n;for(n=0;n<t.length;n++)me(t[n])}}function Je(e,t){if(e!==null)throw t}function Fe(e){if(e.flags&ne)return;const t=e.value,n=l;l=e;try{Se(e),t!==null&&t();const u=Ce(e);typeof u=="function"&&(e.value=u)}catch(u){const r=e.block;if(r!==null)Je(r,u);else throw u}finally{l=n}const s=e.context;Q(s)&&e.flags&G&&i.length>0&&je(s)}function D(e){const t=e.length;if(t>0){if(U>100)throw new Error("Maximum update depth exceeded. This can happen when a reactive block or effect repeatedly sets a new value. Svelte limits the number of nested updates to prevent infinite loops.");U++;let n;for(n=0;n<t;n++){const s=e[n],u=s.flags;!(u&ne)&&!(u&V)&&(_e(s)?(x(s,h),Fe(s)):u&F&&x(s,h))}e.length=0}}function Qe(){if(z=!1,U>101)return;const e=i,t=C;i=[],C=[],D(e),D(t),z||(U=0)}function W(e,t){const n=e.flags;t||n&ie?(Fe(e),x(e,h)):(X===Te&&(z||(z=!0,queueMicrotask(Qe))),n&L?C.push(e):i.push(e))}function De(){J=!1;const e=se.slice();se=[];for(let t=0;t<e.length;t++)e[t]()}function xt(e){J||(J=!0,setTimeout(De,0)),se.push(e)}function Ze(){const e=[];for(let t=0;t<i.length;t++){const n=i[t];n.flags&I&&n.context===f&&(e.push(n),i.splice(t,1),t--)}D(e)}function je(e){const t=[];for(let n=0;n<i.length;n++){const s=i[n];s.flags&G&&s.context===e&&(t.push(s),i.splice(n,1),n--)}D(t)}function Ie(e){const t=X,n=i,s=C;try{const u=[],r=[];X=Be,U=0,i=u,C=r,D(n),D(s),(i.length>0||r.length>0)&&Ie(),J&&De()}finally{X=t,i=n,C=s}}async function kt(){await Promise.resolve(),Ie()}function Ae(e,t){const n=Ce(e),s=M||l===null&&e.flags&te?m:h;x(e,s);const u=e.equals;u(n,e.value)||(e.value=n,de(e,m,t))}function Et(e,t,n){let s=n[t];const u=s===void 0;u&&(s={store:null,last_value:null,value:Re(P),unsubscribe:ce},rt(s.value,()=>{s.last_value=s.value.value}),n[t]=s),(u||s.store!==e)&&(s.unsubscribe(),s.store=e??null,s.unsubscribe=et(e,s.value));const r=S(s.value);return r===P?s.last_value:r}function et(e,t){return e==null?(re(t,void 0),ce):$e(e,s=>{ue=!0,re(t,s),ue=!1})}function wt(e){lt(()=>{let t;for(t in e){const n=e[t];n.unsubscribe(),me(n.value)}})}function S(e){const t=e.flags;if(t&ne)return P;if(b!==null&&!(b.flags&H)&&!v){const n=(b.flags&te)!==0,s=b.dependencies;a===null&&s!==null&&s[d]===e&&!(n&&l!==null)?d++:a===null?a=[e]:e.read!==$&&a.push(e),n||(e.read=$)}return t&fe&&_e(e)&&Ae(e,!1),e.value}function re(e,t){return pe(e,t),t}function tt(e){const t=R;R=null;try{const n=e();return R===null?n:R}finally{R=t}}function qt(e,t){return pe(e,j(()=>S(e))),t}function nt(e,t){const n=e.flags;(!(n&V)&&t||n&V&&!t)&&(e.flags^=V,!t&&n&ae&&!(n&h)&&W(e,!1));const s=e.references;if(s!==null){let u;for(u=0;u<s.length;u++)nt(s[u],t)}}function de(e,t,n){const s=Q(e.context),u=e.consumers;if(u!==null){const r=u.length;let o;for(o=0;o<r;o++){const c=u[o],g=c.flags;g&m||!s&&c===l||!n&&c===l||(x(c,t),g&h&&(c.flags&ae?W(c,!1):de(c,F,n)))}}}function pe(e,t){if(!v&&!ue&&b!==null&&Q(e.context)&&b.flags&fe)throw new Error(`Unsafe mutations during Svelte's render or derived phase are not permitted in runes mode. This can lead to unexpected errors and possibly cause infinite loops.

If this mutation is not meant to be reactive do not use the "$state" rune for that declaration.`);if(e.flags&qe&&!e.equals(t,e.value)){const n=e.context;if(e.value=t,Q(n)&&l!==null&&l.consumers===null&&l.flags&h&&a!==null&&a.includes(e)&&(x(l,m),W(l,!1)),de(e,m,!0),l===null&&i.length===0){const s=n?.update_callbacks;if(s!=null){s.before.forEach(r=>r());const u=ut(()=>{me(u),s.after.forEach(r=>r())})}}}}function me(e){const t=e.value,n=e.destroy;if(Se(e),Z(e,0,!0),e.init=null,e.references=null,e.destroy=null,e.context=null,e.block=null,e.value=null,e.dependencies=null,e.consumers=null,x(e,ne),n!==null)if(ke(n)){let s;for(s=0;s<n.length;s++)n[s]()}else n();t!==null&&e.flags&ae&&t()}function Re(e,t){const n=Ne(qe|h,e,null);return n.context=f,n.equals=Me(t),n}function Me(e){if(e!==void 0)return e;const t=f;return t&&!t.immutable?ot:Xe}function j(e){const t=v;try{return v=!0,e()}finally{v=t}}function N(e,t,n,s,u){const r=Ne(e|m,null,s);return r.init=t,r.context=f,u&&W(r,n),l!==null&&!(e&H)&&ze(l,r),r}function st(e){if(l===null)throw new Error("The Svelte $effect rune can only be used during component initialisation.");const t=l.flags&I&&f!==null&&!f.mounted,n=N(L,e,!1,y,!t);if(t){let s=f.effects;s===null&&(s=f.effects=[]),s.push(n)}return n}function Tt(e){return N(L,e,!1,y,!0)}function ut(e){return N(L|H,e,!1,y,!0)}function Nt(e,t){return N(G|H,e,t,y,!0)}function Ct(e){const t=l!==null&&(l.flags&I)!==0;return N(G,()=>{const n=e();return Ze(),n},t,y,!0)}function ge(e){return N(ie,e,!0,y,!0)}function St(e,t=y,n=!1,s=!0){let u=I;return n&&(u|=H),N(u,e,s,t,!0)}function rt(e,t){let n=e.destroy;n===null?e.destroy=t:ke(n)?n.push(t):e.destroy=[n,t]}function x(e,t){const n=e.flags;n&t||(n&F?e.flags^=F:n&h?e.flags^=h:n&m&&(e.flags^=m),e.flags^=t)}function O(e){return typeof e=="object"&&e!==null&&typeof e.flags=="number"}function Ft(e,t,n,s){const u=O(e)?S(e):e,r=tt(()=>u[t]),o=Object.getOwnPropertyDescriptor(u,t)?.set;let c=u[t];const g=c===void 0&&n!==void 0;if(O(r)&&r.value===c&&o===void 0&&Me()===r.equals)return g&&re(r,s?n():n),r;g&&(c=s?n():n);const E=Re(c),B=f.immutable;let w=!1,_=!1,p=!0;if(ge(()=>{const A=(O(e)?S(e):e)[t];if(p){p=!1;return}if(w){w=!1;return}ye(B,A,E.value)&&(_=!0,j(()=>pe(E,A)))}),O(r)&&o!==void 0){let q=!g;ge(()=>{const A=S(E);if(q){q=!1;return}if(_){_=!1;return}ye(B,A,r.value)&&(w=!0,j(()=>o(A)))})}return E}function Dt(e,t){return()=>(O(e)?S(e):e)[t]}function ye(e,t,n){return e?ct(t,n):Oe(t,n)}function ct(e,t){return e!=e?t==t:e!==t}function Oe(e,t){return e!=e?t==t:e!==t||e!==null&&typeof e=="object"||typeof e=="function"}function ot(e,t){return!Oe(e,t)}function lt(e){st(()=>()=>j(e))}function It(e,t=!1,n=!1){const s=Ve(e);s.runes=t,s.immutable=n,f=s}function At(e){const t=f;if(t!==null){const n=t.effects;if(n!==null){t.effects=null;for(let s=0;s<n.length;s++)W(n[s],!1)}f=t.parent,t.mounted=!0}}export{vt as $,dt as A,pt as B,me as C,rt as D,Tt as E,O as F,Fe as G,ft as H,f as I,it as J,pe as K,xt as L,nt as M,Nt as N,ot as O,ut as P,mt as Q,Ft as a,Ct as b,At as c,at as d,Dt as e,re as f,S as g,gt as h,yt as i,ht as j,j as k,wt as l,qt as m,Et as n,y as o,It as p,ke as q,St as r,Re as s,kt as t,st as u,_t as v,bt as w,T as x,be as y,he as z};
